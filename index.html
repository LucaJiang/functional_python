<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
        <title>Functional Python: Practical Paradigms for Readable and Robust Code</title>
    <meta name="description" content="Explore functional programming concepts in Python for cleaner, more maintainable code.">
    <meta name="author" content="Wenxin Jiang">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/league.css" id="theme">
    <link rel="stylesheet" href="dist/theme/black.css" id="theme">
    <link rel="stylesheet" href="css/custom.css">

</head>

<body>
    <div class="reveal">
        <div class="slides">

<section>
    <h2>Functional Python</h2>
    <h3>Practical Paradigms for Readable and Robust Code</h3>
<div style="display: flex; justify-content: center; align-items: center; gap: 4rem; margin-top: 2.5em;">
    <img src="img/pycon_logo.svg" alt="PyCon HK Logo" style="height: 160px;">
    <div style="text-align: center;margin-left: 4rem;margin-right: 4rem;">
        <p style="margin: 0;">Wenxin Jiang</p>
        <p style="margin: 0; font-size: 0.8em;">Oct. 11, 2025</p>
    </div>
    <img src="img/CityU_logo.svg" alt="CityU Logo" style="height: 120px;">
</div>
<aside class="notes">
Good afternoon, everyone. It's a pleasure to be here at PyCon HK.
While object-oriented design gets most of the attention in Python, there's another way of thinking that can make your
code clearer and more reliable. It's called functional programming.
Today, in just 15 minutes, I'll show you how a few simple ideas from functional programming, like writing predictable
functions and avoiding hidden changes to your data, can help you write Python code that's easier to understand, easier
to test, and more enjoyable to work with.
Let's get started.
</aside>
</section>

<section>
    <h2>Who I am</h2>
    <div>
        <ul>
            <li>Wenxin Jiang, Ph.D. Student @ CityUHK</li>
            <li>Major in Biostatistics</li>
            <li>Research interests: Genetics, High Dimensional Statistics</li>
        </ul>
    </div>
    <aside class="notes">
A bit about me: I'm Wenxin Jiang, a PhD student at CityUHK working with large genetics datasets. In my research, I use
both Python and R to analyze complex data. Like many of you, I'm always looking for ways to write code that's
not just correct, but also clear and reliable. That search is what led me to explore functional programming in Python.
And I'm excited to share what I've learned with you today.
    </aside>
</section>

<section>
    <h2>An Illustrative Example</h2>
    <div style="display: flex; justify-content: center; margin-top: 1em;">
        <table style="border-collapse: collapse; width: 70%; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border-radius: 8px; overflow: hidden;">
            <thead>
                <tr style="background: linear-gradient(135deg, #667eea 0%, #667eea 100%); color: white;">
                    <th style="padding: 15px 20px; text-align: left; font-weight: 600; font-size: 1.1em;">Name</th>
                    <th style="padding: 15px 20px; text-align: left; font-weight: 600; font-size: 1.1em;">Class</th>
                    <th style="padding: 15px 20px; text-align: left; font-weight: 600; font-size: 1.1em;">Subject</th>
                    <th style="padding: 15px 20px; text-align: left; font-weight: 600; font-size: 1.1em;">Score</th>
                </tr>
            </thead>
            <tbody>
                <tr style="background-color: rgba(102, 126, 234, 0.1); transition: all 0.3s ease;">
                    <td style="padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">Alice</td>
                    <td style="padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">B01</td>
                    <td style="padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">Art</td>
                    <td style="padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,0.1); font-weight: 600; color: #667eea;">85</td>
                </tr>
                <tr style="background-color: rgba(118, 75, 162, 0.1); transition: all 0.3s ease;">
                    <td style="padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">Bob</td>
                    <td style="padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">B02</td>
                    <td style="padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">English</td>
                    <td style="padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,0.1); font-weight: 600; color: #667eea;">74</td>
                </tr>
                <tr style="background-color: rgba(118, 75, 162, 0.1); transition: all 0.3s ease;">
                    <td style="padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">Charlie</td>
                    <td style="padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">A03</td>
                    <td style="padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">Art</td>
                    <td style="padding: 12px 20px; border-bottom: 1px solid rgba(255,255,255,0.1); font-weight: 600; color: #eb2a2a;">Error</td>
                </tr>
                <tr style="background-color: rgba(102, 126, 234, 0.1); transition: all 0.3s ease;">
                    <td style="padding: 12px 20px;">...</td>
                    <td style="padding: 12px 20px;">...</td>
                    <td style="padding: 12px 20px;">...</td>
                    <td style="padding: 12px 20px;">...</td>
                </tr>
            </tbody>
        </table>
    </div>
    <aside class="notes">
Here's a simple example: a table of student scores. Each row shows a student's name, class, subject, and their score.
You can see one entry has Error indicating the data was missing or corrupted.
In real projects, we often work with messy data like this. We need to clean it, calculate grades, find
averages for each subject or class, and handle errors carefully.
    </aside>
</section>

<section>
<h2>Imperative Style: How To Do</h2>
<div>
    <img src="img/illu_imperative.png" alt="Imperative Code Example" style="width: 70%; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border-radius: 8px;"/>
</div>
<aside class="notes">
This is the imperative way. Just keep the code there and don't read it. In imperative style, we tell the computer exactly how to do everything. We write a for loop to process each row, use try-except to handle errors, and if-elif chains to calculate grades. We manually update statistics step by step. It
works, but it's long and hard to follow, especially when things get more complex. You have to read through all the details to understand the overall logic.
</aside>
</section>

<section>
    <h2>FP Style: What To Do</h2>
    <div>
        <img src="img/illu_fp.png" alt="Functional Code Example" style="width: 70%; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border-radius: 8px;"/>
</div>
<aside class="notes">
Now, in the functional approach, we focus on what we want to achieve, not how. We chain operations together using
methods like pipe, creating a clear pipeline. Each step is a simple function: add grades, filter scores, calculate
averages. This makes the main code shorter, easier to follow, and much simpler to test and modify.
</aside>
</section>

<section>
    <h2>What is FP?</h2>
    <p>Core: <strong>Pure Functions</strong></p>
    <ul>
        <li>Functions with <strong>no side effects</strong></li>
        <li>Avoid global state</li>
        <li>Same result for the same input</li>
        <li>One function, one task</li>
    </ul>
    <aside class="notes">
At its heart, functional programming is about pure functions. A pure function is like a simple math equation: it takes
some input, gives you an output. It doesn't change anything else in your program - no side effects. It
always gives the same result for the same input. And each function should do just one thing well. Pure functions make your code
predictable and easy to test.
    </aside>
</section>

<section>
    <h2>What is FP?</h2>
    <div style="display: flex; justify-content: center; margin-top: 0em;">
        <table style="border-collapse: collapse; width: 80%; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border-radius: 8px; overflow: hidden; font-size: 0.85em;">
            <thead>
                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <th style="padding: 15px 20px; text-align: center; font-weight: 600; width: 33%;">Aspect</th>
                    <th style="padding: 15px 20px; text-align: center; font-weight: 600; width: 33%;">Functions</th>
                    <th style="padding: 15px 20px; text-align: center; font-weight: 600; width: 33%;">Variables</th>
                </tr>
            </thead>
            <tbody>
                <tr style="background-color: rgba(102, 126, 234, 0.15);">
                    <td style="padding: 15px 20px; text-align: center; font-weight: 600; color: #667eea;">Principle</td>
                    <td style="padding: 15px 20px; text-align: center;">
                        <strong style="font-size: 1.1em;">No Side Effects</strong>
                    </td>
                    <td style="padding: 15px 20px; text-align: center;">
                        <strong style="font-size: 1.1em;">Immutability</strong>, Avoid Global State
                    </td>
                </tr>
                <tr style="background-color: rgba(118, 75, 162, 0.1);">
                    <td style="padding: 15px 20px; text-align: center; font-weight: 600; color: #667eea;">Meaning</td>
                    <td style="padding: 15px 20px; text-align: center;">
                        Output depends<br/>only on input
                    </td>
                    <td style="padding: 15px 20px; text-align: center;">
                        Data cannot be<br/>modified
                    </td>
                </tr>
                <tr style="background-color: rgba(102, 126, 234, 0.15);">
                    <td style="padding: 15px 20px; text-align: center; font-weight: 600; color: #667eea;">Result</td>
                    <td style="padding: 15px 20px; text-align: center;">
                        Predictable &<br/>Testable
                    </td>
                    <td style="padding: 15px 20px; text-align: center;">
                        Safe &<br/>Thread-safe
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
    <aside class="notes">
This table shows the two key ideas in functional programming. On the function side, we want no side effects. Functions
shouldn't unexpectedly change other parts of your program. On the variable side, we want immutability. Data shouldn't
be changed once created. These two ideas work together: if your data can't change, your functions can't have side
effects. You codes are safe in multiple threads, which I think is very important in recent released Python versions, where
true parallelism is possible.
    </aside>
</section>

<section>
    <h2>Immutability: The Problem</h2>
    <p style="color: #eb2a2a;">‚ùå Mutable Approach</p>
    <pre><code class="python">scores = [85, 74, 60] # Shared mutable state

def add_bonus(score_list):
    for i in range(len(score_list)):
        score_list[i] += 10  # Modifies original!
    return score_list

original_scores = scores
bonus_scores = add_bonus(scores)

print(original_scores) # Output: [85, 74, 60]  üò± Changed!</code></pre>
<p style="color: #eb2a2a; margin-top: 5px; font-size: 1em;">‚ö†Ô∏è Unexpected mutation causes bugs!</p>
    <aside class="notes">
As we just saw, immutability is a key idea in functional programming. But what happens when we ignore it? Here's a
common pitfall. We have a list of scores, and we pass it to a function to add a bonus. But the function changes the
original list! Now both variables point to the same changed data. This kind of bug is hard to spot, especially in larger
programs where data is shared around. It's exactly why we want to avoid mutable state.
    </aside>
</section>

<section>
    <h2>Immutability: The Solution</h2>
    <p style="color: #4ade80;">‚úÖ Immutable Approach</p>
    <pre><code class="python">scores = [85, 74, 60] # Immutable approach

def add_bonus(score_list):
    # Create new list, don't modify original
    return [score + 10 for score in score_list]

original_scores = scores
bonus_scores = add_bonus(scores)

print(original_scores)
# Output: [85, 74, 60]  ‚úì Unchanged!</code></pre>
    <p style="color: #4ade80; margin-top: 5px; font-size: 1em;">‚úì Original data is safe!</p>
    <aside class="notes">
Now let's look at the functional solution. Instead of changing the original data, we create a brand new list with the
updated values. The original stays safe and unchanged. It makes your
code predictable and prevents some hard-to-find bugs. Sometimes, I found the bug caused by another function hundreds of lines away.
When I found it, it was like a Goblin suddenly jumping out and saying "Surprise! I changed your data!".
    </aside>
</section>

<section>
    <h2>Why FP?</h2>
    <ul>
        <li><strong>Readability:</strong> Focus on "what" rather than "how"</li>
        <li><strong>Modularity:</strong> Small, isolated functions</li>
        <li><strong>Robustness/Testability:</strong> Easier to test</li>
    </ul>
    <aside class="notes">
So why FP?
First, readability: you focus on what you want, not how to do it. Like giving directions by saying "go to the store"
instead of listing every turn.
Second, modularity: small functions are like Lego blocks - easy to combine and reuse.
Third, testability: same input always gives same output. No surprises.
It's about writing code that's easier to read, test, and maintain.
    </aside>
</section>

<section data-visibility="hidden">
    <h2 style="font-size: 1.2em;">Currying & Higher-Order Functions</h2>
<img src="img/currying.jpg" alt="Currying Example" style="width: 70%; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border-radius: 8px;"/>
    <p style="font-size: 0.5em; margin-top: 0pt;">Source: <a href="https://www.linkedin.com/pulse/currying-takes-your-functions-whole-new-level-power-abdul-ghaffar/">Currying takes your functions to a whole new level of flexibility and power!</a></p>
    <aside class="notes">
xx This image shows the key difference: uncurrying is the normal way - passing all arguments at once like f(a, b, c).
Currying breaks this into steps: f(a)(b)(c). Each call takes one argument and returns a new function.
Why does this matter? It lets you create partial functions. You can fix some arguments early and reuse the function in
different ways. This makes your code more flexible and modular.
    </aside>
</section>

<section>
    <h2>Pipeline Style</h2>
    <div style="margin-top: 1em;">
        <!-- <p style="margin-bottom: 0.6em;text-align: left;">Math to Code: </p> -->
        <p style="font-size: 1em; margin-bottom: 1em;">
            $h(g(f(x))) = (h \circ g \circ f)(x)$
        </p>
        <div style="font-size: 0.8em; margin-left: 2em;">
            <div style="margin-bottom: 0em;">
                <p style="color: #eb2a2a; margin-bottom: 0.5em; text-align: left;">‚ùå Nested (Hard to read)</p>
                <pre><code class="python" style="font-size: 1.2em;">result = h(g(f(df), arg1=a), arg2=b)</code></pre>
            </div>
            <div>
                <p style="color: #4ade80; margin-bottom: 0.5em; text-align: left;">‚úÖ Pipeline (Clear flow)</p>
                <pre><code class="python" style="font-size: 1.2em;">result = df.pipe(f).pipe(g, arg1=a).pipe(h, arg2=b)</code></pre>
            </div>
        </div>
    </div>
    <aside class="notes">
Mathematically, we have two ways to present composition of functions. One is through the traditional nested approach, and the other is the pipeline style. Similarly in code, we can either nest function calls or use a pipeline style with pipe.
But nested code is like a maze - you have to find the innermost function and read outward.
The pipeline style fixes this.
It tells a clear story: first apply f, then pipe to g with argument a, then to h with b. The flow is obvious and clean.
    </aside>
</section>

<section>
    <h2>Railway Analogy for Function Composition</h2>
    <div>
        <img src="img/railway_func_combine.png" alt="Railway Pattern" style="width: 70%; background-color: white; box-shadow: 0 4px 6px rgba(255, 255, 255, 0.3); border-radius: 8px;"/>
    </div>
    <p style="font-size: 0.5em; margin-top: 0pt;">Source: <a href="https://speakerdeck.com/swlaschin/railway-oriented-programming-a-functional-approach-to-error-handling?">Railway Oriented Programming</a></p>
    <aside class="notes">
So functional programming is a practical way to build complex behavior from small, reliable
pieces.
Think of each function as a small piece of track. This one turns a pineapple into an apple, and this one turns an apple into a
banana. We can compose them, because the output and the input are same kinds of objects.
Each piece is small, testable, and reusable. If the requirement changes, we can just add functions and change several pieces without rewriting the whole track.
    </aside>
</section>

<section>
    <h2>Railway Analogy for Error Handling</h2>
    <div>
        <img src="img/railway_two_track.png" alt="Railway Pattern Code Example" style="width: 70%; background-color: white; box-shadow: 0 4px 6px rgba(255, 255, 255, 0.3); border-radius: 8px;"/>
    </div>
    <p style="font-size: 0.5em; margin-top: 0pt;">Source: <a href="https://speakerdeck.com/swlaschin/railway-oriented-programming-a-functional-approach-to-error-handling?">Railway Oriented Programming</a></p>
    <aside class="notes">
Now let's add the second track. Top green track for normal values, bottom red track for errors. Each function acts like a switch:
if it succeeds, we stay on the green track; if it fails, we drop to the red track and skip the rest.

In Python, when you raise an exception, it automatically jumps to the nearest except block‚Äîthat's our red bypass. We
write small, composable steps that either return a value or raise a specific error. Then we handle all errors in one
place.
Therefore, our main pipeline stays clean and focused on the happy path. And we don't need nested try-except blocks everywhere.
    </aside>
</section>

<section>
    <h2>Other Interesting Concepts in FP</h2>
    <div style="font-size: 0.8em; margin-top: 1em;">
        <ul>
            <li><strong>Iterators:</strong> <code>for i in iter_obj:</code></li>
            <li><strong>Map/Filter/Reduce:</strong> <code>map(abs, [-1, 1])</code></li>
            <li><strong>List Comprehensions:</strong> <code>[x for x in range(9) if x % 2]</code></li>
            <li><strong>Generators:</strong> Use <code>yield</code> to produce a sequence of values lazily.</li>
            <li><strong>Lazy Evaluation:</strong> Delay computation until necessary, improving performance.</li>
        </ul>
    </div>
<p style="font-size:0.8em; margin-top: 1em;">
    Docs: <a href="https://docs.python.org/3/howto/functional.html#" target="_blank">Functional Programming HOWTO</a>
</p>
    <aside class="notes">
There are other useful functional concepts in Python that can makes our life easier. Iterators let you loop over data without loading it all into memory. You can use map, filter, and reduce to apply a function to every item in a list. List comprehensions provide a concise way to create lists. Generators allow you to produce sequences of values on the fly. And lazy evaluation delays computation until it's really needed, which can boost performance.
    </aside>
</section>


<section>
    <h2>Thank you for attention!</h2>
    <ul>
        <li>Wenxin Jiang</li>
        <li>GitHub: <a href="https://github.com/LucaJiang" target="_blank">LucaJiang</a></li>
        <li>This presentation: <a
                href="https://lucajiang.github.io/functional_python/">lucajiang.github.io/functional_python/</a></li>
    </ul>
    <aside class="notes">
Thank you for your attention. You can find me on GitHub at LucaJiang, and the slides of this talk are available online.
    </aside>
</section>


        </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/math/math.js"></script>
    <link rel="stylesheet" href="plugin/highlight/github-dark.css" id="highlight-theme" />
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/menu/menu.js"></script>
    <script>
        Reveal.initialize({
            controls: true,
            progress: true,
            center: true,
            hash: true,
            // disableLayout: true,
            transition: 'none',
            slideNumber: true,
            showSlideNumber: 'all',
            help: true,
            mathjax3: {
                mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js',
                tex: {
                    inlineMath: [
                        ['$', '$'],
                        ['\\(', '\\)'],
                    ],
                },
                options: {
                    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                },
            },
            menu: {
                titleSelector: 'h1, h2, h3',
                hideMissingTitles: true,
            },
            plugins: [RevealMath.MathJax3, RevealHighlight, RevealNotes, RevealMenu],
            // plugins: [RevealMath.MathJax3, RevealHighlight, RevealNotes],
        });
    </script>
</body>

</html>